<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Measure
status: proposal
stage: 1
contributors: Ben Allen, Jesse Alama
location: https://github.com/tc39/proposal-measure/
</pre>

<emu-intro id="sec-decimal-intro-">
  <h1>Introduction</h1>
  <p>This specification consists of two parts:</p>
  <ul>
    <li>The specification of the <a href="https://github.com/tc39/proposal-measure/" title="Measure proposal (GitHub)">Measure proposal</a> and everything related to it, proposed to be added to ECMA-262 in new sections;</li>
    <li>A list of amendments to be made to ECMA-402.</li>
  </ul>
</emu-intro>

<emu-clause id="sec-the-amount-object">
  <h1>The Amount Object</h1>
  <emu-intro id="sec-amount-intro">
    <h1>Introduction</h1>
    <p>An Amount is an object that wraps a digit String, representing a mathematical value, and a precision. One can intuitively understand an Amount as a number that, so to speak, knows its own precision.</p>
  </emu-intro>

  <emu-clause id="sec-amount-abstract-operations">
    <h1>Abstract Operations</h1>

    <emu-clause id="sec-amount-countsignificantdigits" type="abstract operation">
      <h1>CountSignificantDigits(
        _s_: a digit String
      ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the number of significant digits in a given String, which is assumed to be a digit string in either decimal or exponential notation.</dd>
      </dl>
      <emu-alg>
        1. <mark>Return 42.</mark>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-amount-countfractiondigits" type="abstract operation">
      <h1>CountFractionDigits(
        _s_: a digit String
      ): a non-negative integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the number of fractional digits in a given String, which is assumed to be a digit string in either decimal or exponential notation.</dd>
      </dl>
      <emu-alg>
        1. <mark>Return 42.</mark>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-amount-applyroundingmodetopositive" type="abstract operation">
      <h1>ApplyRoundingModeToPositive(
        _m_: a positive mathematical value,
        _roundingMode_: a rounding mode
      ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the closest integer approximation to a given positive mathematical value, rounded according to the given rounding mode.</dd>
      </dl>
      <emu-alg>
        1. Let _mLow_ be floor(_m_).
        1. Let _fraction_ be _m_ – _mLow_.
        1. If _fraction_ = 0, return _mLow_.
        1. Let _mHigh_ be _mLow_ + 1.
        1. If _roundingMode_ is *"floor"* or *"trunc"*, return _mLow_.
        1. If _roundingMode_ is *"ceil"*, return _mHigh_.
        1. If _fraction_ < 0.5, return _mLow_.
        1. If _fraction_ > 0.5, return _mHigh_.
        1. If _roundingMode_ is *"halfExpand"*, return _mHigh_.
        1. If _mLow_ is an even integer, return _mLow_.
        1. Return _mHigh_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-amount-roundtoamountdomain" type="abstract operation">
      <h1>RoundToAmountDomain(
        _v_: a mathematical value,
        optional _roundingMode_: a rounding mode
      ): ~minus-zero~ or a mathematical value
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It computes the closest approximation to a given mathematical value, rounded according to the given rounding mode, that is available within the limits imposed by Amount.</dd>
      </dl>
      <emu-alg>
        1. If _v_ = 0, return 0.
        1. If v < 0, then
          1. Let _reverseRoundingMode_ be _roundingMode_.
          1. If _roundingMode_ is *"floor"*, set _reverseRoundingMode_ to *"ceil"*.
          1. If _roundingMode_ is *"ceil"*, set _reverseRoundingMode_ to *"floor"*.
          1. Let _d_ be RoundToAmountDomain(–_v_, _reverseRoundingMode_).
          1. Assert: _d_ is a mathematical value.
          1. If _d_ is 0, return ~minus-zero~.
          1. Return –_d_.
        1. If _v_ > MAX_INTEGER, return MAX_INTEGER.
        1. Let _e_ be the unique integer such that 10<sup>_e_</sup> ≤ _v_ < 10<sup>_e_+1</sup>.
        1. If _e_ < –100, set _e_ to –100.
        1. Let _m_ be _v_ × 10<sup>–_e_</sup>.
        1. Let _rounded_ be ApplyRoundingModeToPositive(_m_, _roundingMode_).
        1. Return _rounded_ × 10<sup>_e_</sup>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-amount-rendermvwithfractiondigits" type="abstract operation">
      <h1>RenderMVWithFractionDigits(
        _v_: a mathematical value,
        _numDigits_: a non-negative integer,
        optional _roundingMode_: a rounding mode
      ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It renders the given mathematical value with a given number of fractional digits, possibly rounding if necessary, using the given rounding mode, which, if missing, is *"halfEven"*.</dd>
      </dl>
      <emu-alg>
        1. If _roundingMode_ is *undefined*, let _mode_ be *"halfEven"*, else let _mode_ be _roundingMode_.
        1. If _v_ < 0, let _prefix_ be *"-"*, else let _prefix_ be "".
        1. If _v_ < 0, set _v_ to -_v_.
        1. Let _rounded_ be ApplyRoundingModeToPositive(_v_ × 10<sup>_numDigits_</sup>, _mode_).
        1. Set _v_ to _rounded_ × 10<sup>-_numDigits_</sup>.
        1. Let _e_ be the smallest non-negative integer such that _v_ × 10<sup>-_numDigits_</sup> is an integer.
        1. Let _s_ be the unique decimal string representation of _v_ without leading zeroes.
        1. If _numDigits_ > _e_, then
          1. If _v_ is an integer, return the string concatenation of _prefix, _s_, *"."*, and *"0"* repeated _numDigits_ times.
          1. Otherwise, return the string concatenation of _prefix_, _s_ and *"0"* repeated _numDigits_ - _e_ times.
        1. Otherwise:
          1. Return the string concatenation of _prefix, _s_ and *"0"* repeated _e_ - _numDigits_ times.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-the-amount-constructor">
    <h1>The Amount Constructor</h1>
    <p>The Amount constructor:</p>
    <ul>
      <li>is <dfn>%Amount%</dfn>.</li>
      <li>is the initial value of the the *"Amount"* property of the global object.</li>
      <li>creates and initializes a new Amount object when called as a constructor</li>
      <li>may be used as the value of an *extends* clause of a class definition.</li>
    </ul>
    <emu-clause id="sec-the-amount-constructor-value">
      <h1>Amount ( _x_ [ , _opts_ ] )</h1>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _toParse_ be *undefined*.
        1. Let _roundingMode_ be *"halfEven"*.
        1. Let _unit_ be *undefined*.
        1. Let _currency_ be *undefined*.
        1. Let _significantDigits_ be *undefined*.
        1. Let _fractionDigits_ be *undefined*.
        1. If _x_ is a BigInt, set _toParse_ to ! Call(%BigInt.prototype.toString%, _x_, « »).
        1. Otherwise, if _x_ is a Number, set _toParse_ to ! Call(%Number.prototype.toString%, _x_, « »).
        1. Otherwise, if _x_ is a String, set _toParse_ to _x_.
        1. If _toParse_ is not a String, throw a *TypeError* exception.
        1. If _opts_ is not *undefined*, then
          1. If _opts_ is not an Object, throw a *TypeError* exception.
          1. Let _roundingModeFromOpts_ be ? Get (_opts_, *"roundingMode"*).
          1. Let _unitFromOpts_ be ? Get (_opts_, *"unit"*).
          1. Let _currencyFromOpts_ be ? Get (_opts_, *"currency"*).
          1. Let _significantDigitsFromOpts_ be ? Get (_opts_, *"significantDigits"*).
          1. Let _fractionDigitsFromOpts_ be ? Get (_opts_, *"fractionDigits"*).
          1. If _roundingModeFromOpts_ is not a String, thrown a *TypeError* exception.
          1. If _roundingModeFromOpts_ is not a rounding mode, throw a *RangeError* exception.
          1. Set _roundingMode_ to _roundingModeFromOpts_.
          1. If _currencyFromOpts_ is not *undefined* and _unitFromOpts_ is not *undefined*, throw a *RangeError* exception.
          1. If _currencyFromOpts_ is not *undefined* and not a String, throw a *TypeError* exception.
          1. If _unitFromOpts_ is not *undefined* and not a String, throw a *TypeError* exception.
          1. If _fractionDigitsFromOpts_ is not *undefined, then
            1. If _fractionDigitsFromOpts_ is not a Number, throw a *TypeError* exception.
            1. If ℝ(_fractionDigitsFromOpts_) is not an integer, throw a *RangeError* exception.
            1. If ℝ(_fractionDigitsFromOpts_) < 0, throw a *RangeError* exception.
            1. If ℝ(_fractionDigitsFromOpts_) > 100, throw a *RangeError* exception.
            1. Set _fractionDigits_ to ℝ(_fractionDigitsFromOpts_).
          1. If _significantDigitsFromOpts_ is not *undefined*, then
            1. If _significantDigitsFromOpts_ is not a Number, throw a *TypeError* exception.
            1. If ℝ(_significantDigitsFromOpts_) is not an integer, throw a *RangeError* exception.
            1. If ℝ(_significantDigitsFromOpts_) < 1, throw a *RangeError* exception.
            1. If ℝ(_significantDigitsFromOpts_) > 20, throw a *RangeError* exception.
            1. Set _significantDigits_ to ℝ(_significantDigitsFromOpts_).
        1. If _toParse_ is in « *"NaN"*, *"Infinity"*, *"-Infinity"* », throw a *RangeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Amount.prototype%"*, « [[AmountData]], [[SignificantDigits]], [[FractionDigits]], [[Unit]] »).
        1. Let _parseResult_ be ParseText(_toParse_, |StrDecimalLiteral|).
        1. If _parseResult_ is a List of errors, throw a *SyntaxError* exception.
        1. Let _amountValue_ be ? StringDecimalValue of _parseResult_.
        1. Let _roundedAmountValue_ be RoundToAmountDomain(_amountValue_, _roundingMode_).
        1. If _significantDigits_ is *undefined*, set _significantDigits_ to CountSignificantDigits(_toParse_).
        1. If _fractionDigits_ is *undefined*, set _fractionDigits_ to CountFractionDigits(_toParse_).
        1. Set _O_.[[AmountData]] to _roundedAmountValue_.
        1. Set _O_.[[SignificantDigits]] to _significantDigits_.
        1. Set _O_.[[FractionDigits]] to _fractionDigits_.
        1. If _unit_ is a String, set _O_.[[Unit]] to toLowercase(StringToCodePoints(_unit_)).
        1. If _currency_ is a String, set _O_.[[Unit]] to toUppercase(StringToCodePoints(_unit_)).
        1. Return _O_.
      </emu-alg>
      <emu-note>
        <p>Given a Number argument, the constructor converts it to a String using the <emu-xref href="#sec-number.prototype.tostring">toString</emu-xref> method (with no arguments). In some cases, this may not be desired; consider passing in a String form of a Number using the <emu-xref href="#sec-number.prototype.tofixed">toFixed</emu-xref> or <emu-xref href="#sec-number.prototype.toprecision">toPrecision</emu-xref> methods.</p>
      </emu-note>
      <emu-clause id="sec-runtime-semantics-stringdecimalvalue" type="sdo">
        <h1>Runtime Semantics: StringDecimalValue ( ): either a normal completion containing either a mathematical value or ~minus-zero~ or a throw completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
        <emu-alg>
          1. Let _a_ be ? StringAmountValue of |StrUnsignedDecimalLiteral|.
          1. Assert: _a_ is finite.
          1. If _a_ is 0, return ~minus-zero~.
          1. Return −_a_.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
        <emu-alg>
          1. Throw a *RangeError* exception.
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of the first |DecimalDigits|.
          1. If the second |DecimalDigits| is present, then
            1. Let _b_ be MV of the second |DecimalDigits|.
            1. Let _n_ be the number of code points in the second |DecimalDigits|.
          1. Else,
            1. Let _b_ be 0.
            1. Let _n_ be 0.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundToAmountDomain((_a_ + (_b_ × 10<sup>−_n_</sup>)) × 10<sup>_e_</sup>).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _b_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Let _newValue_ be _b_ × 10<sup>_e_ − _n_</sup>.
          1. Return RoundToAmountDomain(_newValue_).
        </emu-alg>
        <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
        <emu-alg>
          1. Let _a_ be MV of |DecimalDigits|.
          1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.
          1. Return RoundToAmountDomain(_a_ × 10<sup>_e_</sup>).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-amount-prototype-properties">
  <h1>Properties of the Amount Prototype</h1>

  <emu-clause id="sec-amount.prototype.tostring">
    <h1>Amount.prototype.toString ( [ _options_ ] )</h1>
    <p>This method returns a String value that renders the underling mathematical value according to its precision, as well as any unit or currency indicators, if present.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[AmountData]]).
      1. Perform ? RequireInternalSlot(_O_, [[FractionDigits]]).
      1. If _options_ is not *undefined*, then
        1. If _options_ is not an Object, throw a *TypeError* exception.
      1. Let _v_ be _O_.[[AmountData]].
      1. Let _numDigits_ be _O_.[[FractionDigits]].
      1. Assert: _numDigits_ is a non-negative integer.
      1. Let _roundingMode_ be *"halfEven"*.
      1. If _options_ is not *undefined*, then
        1. Let _roundingModeFromOpts_ be ? Get(_options_, *"roundingMode"*).
        1. If _roundingModeFromOpts_ is not *undefined*, then
          1. If _roundingModeFromOpts_ is not a String, throw a *TypeError* exception.
          1. If _roundingModeFromOpts_ is not a rounding mode, throw a *RangeError* exception.
          1. Set _roundingMode_ to _roundingModeFromOpts_.
      1. Let _s_ be RenderMVWithFractionDigits(_v_, _numDigits_, _roundingMode_).
      1. If _O_.[[Unit]] is *undefined*, return _s_.
      1. Otherwise, return the string concatenation of _s_, *"["*, _O_.[[Unit]], and *"]"*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.tolocalestring">
    <h1>Amount.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
      <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
      <p>This method produces a String value that represents this Amount object formatted according to the conventions of the host environment’s current locale. This method is implementation-defined, and it is permissible, but not encouraged, for it to return the same thing as <emu-xref href="#sec-amount.prototype.tostring">`toString`</emu-xref>.</p>
      <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
  </emu-clause>

  <emu-clause id="sec-amount.prototype.with">
    <h1>Amount.prototype.with ( _options_ )</h1>
    <p>This method returns a fresh Amount object whose underlying mathematical value is equal to the mathematical value of the current Amount, but possibly with different precision as specified in the _options_.</p>
    <p>It performs the following steps when called:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[AmountData]]).
      1. If _options_ is not an Object, throw a *TypeError* exception.
      1. Let _v_ be _O_.[[AmountData]].
      1. Let _s_ be Number::toString(_v_, 10).
      1. Return ? Call (%Amount%, _O_, « _s_, _options_ »).
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-import href="./intl.emu"></emu-import>
